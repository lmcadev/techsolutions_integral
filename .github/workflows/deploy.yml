name: Deploy a VPS via Portainer (Beta)

on:
  push:
    branches: [ beta ]
  pull_request:
    branches: [ beta ]
    types: [ closed ]

  # Permitir ejecución manual
  workflow_dispatch:

env:
  NODE_VERSION: '18'
  PORTAINER_STACK_NAME: 'techsolutions-integral-beta'
  DOMAIN: 'techsolutions.lmcadev.com'
  BRANCH: 'beta'

jobs:
  # tests antes del despliegue
  test:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    # Servicio PostgreSQL para tests
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
          POSTGRES_HOST_AUTH_METHOD: trust
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: backend/package-lock.json

    - name: Instalar dependencias del backend
      run: |
        cd backend
        npm ci

    - name: Realizar pruebas del backend
      run: |
        cd backend
        npm run test
      env:
        NODE_ENV: test
        # Variables de base de datos para tests
        PGHOST: localhost
        PGPORT: 5432
        PGUSER: test_user
        PGPASSWORD: test_password
        PGDATABASE: test_db
        DATABASE_URL: postgres://test_user:test_password@localhost:5432/test_db
        # Variables de auth para tests
        JWT_SECRET: test_jwt_secret_for_testing
        JWT_EXPIRES_IN: 1h

  # despliegue via Portainer
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    permissions:
      contents: read
      packages: write

    steps:
    - name: Verificar codigo
      uses: actions/checkout@v4

    - name: Preparar Docker Compose Stack
      run: |
        # Crear docker-compose.portainer.yml con variables de entorno
        cat << EOF > docker-compose.portainer.yml
        version: '3.8'

        services:
          # Backend API
          backend:
            image: ghcr.io/${{ github.repository_owner }}/techsolutions-backend:${{ github.sha }}
            container_name: techsolutions_backend
            environment:
              - NODE_ENV=production
              - PORT=3000
              - PGHOST=db
              - PGPORT=5432
              - PGUSER=${{ secrets.DB_USER }}
              - PGPASSWORD=${{ secrets.DB_PASSWORD }}
              - PGDATABASE=${{ secrets.DB_NAME }}
              - DATABASE_URL=postgres://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@db:5432/${{ secrets.DB_NAME }}
              - JWT_SECRET=${{ secrets.JWT_SECRET }}
              - JWT_EXPIRES_IN=7d
              - FRONTEND_URL=https://${{ env.DOMAIN }}
              - RATE_LIMIT_WINDOW_MS=900000
              - RATE_LIMIT_MAX_REQUESTS=100
              - BCRYPT_SALT_ROUNDS=12
            networks:
              - techsolutions_network
            restart: unless-stopped
            healthcheck:
              test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:3000/api/health"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 60s
            labels:
              - "traefik.enable=true"
              - "traefik.http.routers.techsolutions-api.rule=Host(\`${{ env.DOMAIN }}\`) && PathPrefix(\`/api\`)"
              - "traefik.http.routers.techsolutions-api.tls=true"
              - "traefik.http.routers.techsolutions-api.tls.certresolver=letsencrypt"
              - "traefik.http.services.techsolutions-api.loadbalancer.server.port=3000"

          # Frontend Angular
          frontend:
            image: ghcr.io/${{ github.repository_owner }}/techsolutions-frontend:${{ github.sha }}
            container_name: techsolutions_frontend
            networks:
              - techsolutions_network
            restart: unless-stopped
            healthcheck:
              test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:80"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 30s
            labels:
              - "traefik.enable=true"
              - "traefik.http.routers.techsolutions-frontend.rule=Host(\`${{ env.DOMAIN }}\`)"
              - "traefik.http.routers.techsolutions-frontend.tls=true"
              - "traefik.http.routers.techsolutions-frontend.tls.certresolver=letsencrypt"
              - "traefik.http.services.techsolutions-frontend.loadbalancer.server.port=80"

          # PostgreSQL DB
          db:
            image: postgres:15-alpine
            container_name: techsolutions_db
            environment:
              - POSTGRES_USER=${{ secrets.DB_USER }}
              - POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}
              - POSTGRES_DB=${{ secrets.DB_NAME }}
              - POSTGRES_INITDB_ARGS=--encoding=UTF-8
            volumes:
              - db_data:/var/lib/postgresql/data
            networks:
              - techsolutions_network
            restart: unless-stopped
            healthcheck:
              test: ["CMD-SHELL", "pg_isready -U ${{ secrets.DB_USER }} -d ${{ secrets.DB_NAME }}"]
              interval: 30s
              timeout: 10s
              retries: 5
              start_period: 60s

        networks:
          techsolutions_network:
            driver: bridge

        volumes:
          db_data:
            driver: local
        EOF

    - name: Construir y subir imágenes Docker
      run: |
        # Login a github container registry
        echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
        
        # Construir imagen backend
        docker build -t ghcr.io/${{ github.repository_owner }}/techsolutions-backend:${{ github.sha }} ./backend
        docker push ghcr.io/${{ github.repository_owner }}/techsolutions-backend:${{ github.sha }}
        
        # Construir imagen frontend
        docker build -t ghcr.io/${{ github.repository_owner }}/techsolutions-frontend:${{ github.sha }} ./techsolutions_integral
        docker push ghcr.io/${{ github.repository_owner }}/techsolutions-frontend:${{ github.sha }}
        
        # Tags para beta
        docker tag ghcr.io/${{ github.repository_owner }}/techsolutions-backend:${{ github.sha }} ghcr.io/${{ github.repository_owner }}/techsolutions-backend:beta
        docker tag ghcr.io/${{ github.repository_owner }}/techsolutions-frontend:${{ github.sha }} ghcr.io/${{ github.repository_owner }}/techsolutions-frontend:beta
        docker push ghcr.io/${{ github.repository_owner }}/techsolutions-backend:beta
        docker push ghcr.io/${{ github.repository_owner }}/techsolutions-frontend:beta
        
        # Mantener también latest para compatibilidad
        docker tag ghcr.io/${{ github.repository_owner }}/techsolutions-backend:${{ github.sha }} ghcr.io/${{ github.repository_owner }}/techsolutions-backend:latest
        docker tag ghcr.io/${{ github.repository_owner }}/techsolutions-frontend:${{ github.sha }} ghcr.io/${{ github.repository_owner }}/techsolutions-frontend:latest
        docker push ghcr.io/${{ github.repository_owner }}/techsolutions-backend:latest
        docker push ghcr.io/${{ github.repository_owner }}/techsolutions-frontend:latest

    - name: Deploy a Portainer
      run: |
        # Configurar URL de Portainer
        PORTAINER_URL="http://145.223.79.134:9000"
        
        # Verificar conectividad a Portainer
        echo "Verificando conectividad a Portainer..."
        echo "URL: $PORTAINER_URL/api/auth"
        
        # Verificar que Portainer esté accesible
        echo "Probando conectividad básica..."
        if ! curl -s --connect-timeout 10 "$PORTAINER_URL" > /dev/null; then
          echo "Error: No se puede conectar a Portainer en $PORTAINER_URL"
          echo "Verificar:"
          echo "  - El servidor VPS está activo"
          echo "  - Portainer está ejecutándose en el puerto 9000"
          echo "  - No hay firewall bloqueando el puerto"
          exit 1
        fi
        echo "Conectividad básica OK"
        
        # Obtener token de Portainer con manejo de errores
        echo "Intentando autenticación con Portainer..."
        AUTH_RESPONSE=$(curl -s -w "%{http_code}" -X POST "$PORTAINER_URL/api/auth" \
          -H "Content-Type: application/json" \
          -d '{"Username": "${{ secrets.PORTAINER_USERNAME }}", "Password": "${{ secrets.PORTAINER_PASSWORD }}"}')
        
        HTTP_STATUS="${AUTH_RESPONSE: -3}"
        RESPONSE_BODY="${AUTH_RESPONSE%???}"
        
        echo "HTTP Status: $HTTP_STATUS"
        echo "Response: $RESPONSE_BODY"
        
        if [ "$HTTP_STATUS" != "200" ]; then
          echo "Error: Falló la autenticación con Portainer (Status: $HTTP_STATUS)"
          echo "Verificar:"
          echo "  - URL de Portainer: $PORTAINER_URL"
          echo "  - Credenciales de Portainer (Username: ${{ secrets.PORTAINER_USERNAME }})"
          echo "  - Conectividad de red"
          exit 1
        fi
        
        ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r .jwt 2>/dev/null)
        
        if [ "$ACCESS_TOKEN" = "null" ] || [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "" ]; then
          echo "Error: No se pudo extraer el token JWT de la respuesta"
          echo "Respuesta completa: $RESPONSE_BODY"
          exit 1
        fi
        
        echo "Token de Portainer obtenido exitosamente"
        
        # Obtener información del environment 'local'
        echo "Obteniendo información de environments..."
        ENVIRONMENTS=$(curl -s -X GET "$PORTAINER_URL/api/endpoints" \
          -H "Authorization: Bearer $ACCESS_TOKEN")
        echo "Environments encontrados: $ENVIRONMENTS"
        
        LOCAL_ENV_ID=$(echo "$ENVIRONMENTS" | jq -r '.[] | select(.Name == "local") | .Id')
        echo "Local Environment ID: $LOCAL_ENV_ID"
        
        if [ "$LOCAL_ENV_ID" = "" ] || [ "$LOCAL_ENV_ID" = "null" ]; then
          echo "Error: No se encontró el environment 'local'"
          exit 1
        fi
        
        # Verificar si el stack existe
        echo "Listando stacks existentes..."
        STACKS_LIST=$(curl -s -X GET "$PORTAINER_URL/api/stacks" \
          -H "Authorization: Bearer $ACCESS_TOKEN")
        echo "Stacks encontrados: $STACKS_LIST"
        
        STACK_ID=$(echo "$STACKS_LIST" | jq -r '.[] | select(.Name == "${{ env.PORTAINER_STACK_NAME }}") | .Id')
        echo "Stack ID encontrado: $STACK_ID"
        
        # Preparar el archivo docker-compose como string JSON
        echo "Preparando contenido del docker-compose..."
        DOCKER_COMPOSE_CONTENT=$(cat docker-compose.portainer.yml | jq -Rs .)
        
        if [ "$STACK_ID" = "" ]; then
          echo "Creando nuevo stack en Portainer..."
          echo "Nombre del stack: ${{ env.PORTAINER_STACK_NAME }}"
          echo "Local Environment ID: $LOCAL_ENV_ID"
          
          # Crear nuevo stack usando compose/docker-compose
          RESPONSE=$(curl -s -w "%{http_code}" -X POST "$PORTAINER_URL/api/stacks/create/standalone/string?endpointId=$LOCAL_ENV_ID" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{
              \"name\": \"${{ env.PORTAINER_STACK_NAME }}\",
              \"stackFileContent\": $DOCKER_COMPOSE_CONTENT
            }")
          
          HTTP_STATUS="${RESPONSE: -3}"
          RESPONSE_BODY="${RESPONSE%???}"
          
          echo "Status creación: $HTTP_STATUS"
          echo "Respuesta creación: $RESPONSE_BODY"
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "Error creando stack (Status: $HTTP_STATUS)"
            echo "Respuesta completa: $RESPONSE_BODY"
            exit 1
          fi
          
          NEW_STACK_ID=$(echo "$RESPONSE_BODY" | jq -r .Id)
          echo "Stack creado con ID: $NEW_STACK_ID"
          
        else
          echo "Actualizando stack existente (ID: $STACK_ID)..."
          
          # Actualizar stack existente
          UPDATE_RESPONSE=$(curl -s -w "%{http_code}" -X PUT "$PORTAINER_URL/api/stacks/$STACK_ID?endpointId=$LOCAL_ENV_ID" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{
              \"stackFileContent\": $DOCKER_COMPOSE_CONTENT
            }")
          
          UPDATE_HTTP_STATUS="${UPDATE_RESPONSE: -3}"
          UPDATE_RESPONSE_BODY="${UPDATE_RESPONSE%???}"
          
          echo "Status actualización: $UPDATE_HTTP_STATUS"
          echo "Respuesta actualización: $UPDATE_RESPONSE_BODY"
          
          if [ "$UPDATE_HTTP_STATUS" != "200" ]; then
            echo "Error actualizando stack (Status: $UPDATE_HTTP_STATUS)"
            echo "Respuesta completa: $UPDATE_RESPONSE_BODY"
            exit 1
          fi
          
          echo "Stack actualizado exitosamente"
        fi

    - name: Verificar el despliegue
      run: |
        # Esperar a que los contenedores se levanten
        sleep 60
        
        # Configurar URL de Portainer
        PORTAINER_URL="http://145.223.79.134:9000"
        
        # Obtener token de Portainer para verificación
        echo "Obteniendo token para verificación..."
        AUTH_RESPONSE=$(curl -s -w "%{http_code}" -X POST "$PORTAINER_URL/api/auth" \
          -H "Content-Type: application/json" \
          -d '{"Username": "${{ secrets.PORTAINER_USERNAME }}", "Password": "${{ secrets.PORTAINER_PASSWORD }}"}')
        
        HTTP_STATUS="${AUTH_RESPONSE: -3}"
        RESPONSE_BODY="${AUTH_RESPONSE%???}"
        
        if [ "$HTTP_STATUS" != "200" ]; then
          echo "Warning: No se pudo obtener token para verificación (Status: $HTTP_STATUS)"
          echo "Saltando verificación de Portainer API..."
        else
          ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r .jwt 2>/dev/null)
        fi
        
        # Verificar estado del stack solo si tenemos token válido
        if [ "$ACCESS_TOKEN" != "null" ] && [ ! -z "$ACCESS_TOKEN" ]; then
          STACK_STATUS=$(curl -s -X GET "$PORTAINER_URL/api/stacks" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            | jq -r '.[] | select(.Name == "${{ env.PORTAINER_STACK_NAME }}") | .Status' 2>/dev/null)
          
          echo "Estado del stack: $STACK_STATUS"
        else
          echo "Sin token válido, saltando verificación de stack"
        fi
        
        # Verificar que la aplicación responda
        echo "Verificando health de la aplicación..."
        
        # Intentar conectar a la API a través del dominio
        for i in {1..10}; do
          if curl -f "https://${{ env.DOMAIN }}/api/health" > /dev/null 2>&1; then
            echo "API está funcionando correctamente en https://${{ env.DOMAIN }}/api/health"
            break
          fi
          echo "Intento $i/10: API no responde, esperando..."
          sleep 15
        done
        
        # Verificar frontend
        if curl -f "https://${{ env.DOMAIN }}" > /dev/null 2>&1; then
          echo "Frontend está funcionando correctamente en https://${{ env.DOMAIN }}"
        else
          echo "Frontend podría no estar respondiendo correctamente"
        fi

    - name: Notification on Success
      if: success()
      run: |
        echo "Despliegue BETA exitoso en Hostinger VPS via Portainer!"
        echo "Aplicación BETA disponible en: https://${{ env.DOMAIN }}"
        echo "Backend API BETA: https://${{ env.DOMAIN }}/api/health"
        echo "Rama desplegada: ${{ env.BRANCH }}"
        echo "Stack: ${{ env.PORTAINER_STACK_NAME }}"
        echo "CloudPanel: Configurado con dominio ${{ env.DOMAIN }}"

    - name: Notification on Failure
      if: failure()
      run: |
        echo "Error en el despliegue BETA via Portainer. Revisa los logs para más detalles."
        echo "Rama afectada: ${{ env.BRANCH }}"
        echo "Stack: ${{ env.PORTAINER_STACK_NAME }}"
        echo "Verifica:"
        echo "  - Credenciales de Portainer"
        echo "  - Configuración de CloudPanel"
        echo "  - Estado de los contenedores en Portainer"
        echo "  - Logs del workflow en GitHub Actions"

  # Job para rollback en caso de fallo via Portainer
  rollback:
    needs: deploy
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
    - name: Rollback Portainer Beta
      run: |
        echo "Iniciando rollback BETA en Portainer..."
        echo "Rama: ${{ env.BRANCH }}"
        echo "Stack: ${{ env.PORTAINER_STACK_NAME }}"
        
        # Configurar URL de Portainer
        PORTAINER_URL="http://145.223.79.134:9000"
        
        # Obtener token de Portainer para rollback
        echo "Obteniendo token para rollback..."
        AUTH_RESPONSE=$(curl -s -w "%{http_code}" -X POST "$PORTAINER_URL/api/auth" \
          -H "Content-Type: application/json" \
          -d '{"Username": "${{ secrets.PORTAINER_USERNAME }}", "Password": "${{ secrets.PORTAINER_PASSWORD }}"}')
        
        HTTP_STATUS="${AUTH_RESPONSE: -3}"
        RESPONSE_BODY="${AUTH_RESPONSE%???}"
        
        if [ "$HTTP_STATUS" != "200" ]; then
          echo "Error: No se pudo obtener token para rollback (Status: $HTTP_STATUS)"
          echo "Rollback manual requerido en Portainer"
          exit 1
        fi
        
        ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r .jwt 2>/dev/null)
        
        # Obtener ID del stack
        STACK_ID=$(curl -s -X GET "$PORTAINER_URL/api/stacks" \
          -H "Authorization: Bearer $ACCESS_TOKEN" \
          | jq -r '.[] | select(.Name == "${{ env.PORTAINER_STACK_NAME }}") | .Id')
        
        if [ "$STACK_ID" != "" ]; then
          # Detener stack fallido
          echo "Deteniendo stack BETA fallido (ID: $STACK_ID)..."
          curl -s -X POST "$PORTAINER_URL/api/stacks/$STACK_ID/stop" \
            -H "Authorization: Bearer $ACCESS_TOKEN"
          
          echo "Rollback BETA completado. Stack detenido."
          echo "Revisa la configuración en Portainer: $PORTAINER_URL"
        else
          echo "No se encontró el stack BETA para rollback"
        fi